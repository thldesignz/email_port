{"ast":null,"code":"import { Circle, CircleWarp, ParticlesInteractorBase } from \"../../../Core\";\nimport { getDistance, getLinkRandomColor } from \"../../../Utils\";\n\nfunction getLinkDistance(pos1, pos2, optDistance, canvasSize, warp) {\n  let distance = getDistance(pos1, pos2);\n\n  if (!warp || distance <= optDistance) {\n    return distance;\n  }\n\n  const pos2NE = {\n    x: pos2.x - canvasSize.width,\n    y: pos2.y\n  };\n  distance = getDistance(pos1, pos2NE);\n\n  if (distance <= optDistance) {\n    return distance;\n  }\n\n  const pos2SE = {\n    x: pos2.x - canvasSize.width,\n    y: pos2.y - canvasSize.height\n  };\n  distance = getDistance(pos1, pos2SE);\n\n  if (distance <= optDistance) {\n    return distance;\n  }\n\n  const pos2SW = {\n    x: pos2.x,\n    y: pos2.y - canvasSize.height\n  };\n  distance = getDistance(pos1, pos2SW);\n  return distance;\n}\n\nexport class Linker extends ParticlesInteractorBase {\n  constructor(container) {\n    super(container);\n  }\n\n  isEnabled(particle) {\n    return particle.options.links.enable;\n  }\n\n  reset() {}\n\n  async interact(p1) {\n    var _a;\n\n    p1.links = [];\n    const pos1 = p1.getPosition();\n    const container = this.container;\n    const canvasSize = container.canvas.size;\n\n    if (pos1.x < 0 || pos1.y < 0 || pos1.x > canvasSize.width || pos1.y > canvasSize.height) {\n      return;\n    }\n\n    const linkOpt1 = p1.options.links;\n    const optOpacity = linkOpt1.opacity;\n    const optDistance = (_a = p1.retina.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;\n    const warp = linkOpt1.warp;\n    const range = warp ? new CircleWarp(pos1.x, pos1.y, optDistance, canvasSize) : new Circle(pos1.x, pos1.y, optDistance);\n    const query = container.particles.quadTree.query(range);\n\n    for (const p2 of query) {\n      const linkOpt2 = p2.options.links;\n\n      if (p1 === p2 || !linkOpt2.enable || linkOpt1.id !== linkOpt2.id || p2.spawning || p2.destroyed || p1.links.map(t => t.destination).indexOf(p2) !== -1 || p2.links.map(t => t.destination).indexOf(p1) !== -1) {\n        continue;\n      }\n\n      const pos2 = p2.getPosition();\n\n      if (pos2.x < 0 || pos2.y < 0 || pos2.x > canvasSize.width || pos2.y > canvasSize.height) {\n        continue;\n      }\n\n      const distance = getLinkDistance(pos1, pos2, optDistance, canvasSize, warp && linkOpt2.warp);\n\n      if (distance > optDistance) {\n        return;\n      }\n\n      const opacityLine = (1 - distance / optDistance) * optOpacity;\n      this.setColor(p1);\n      p1.links.push({\n        destination: p2,\n        opacity: opacityLine\n      });\n    }\n  }\n\n  setColor(p1) {\n    const container = this.container;\n    const linksOptions = p1.options.links;\n    let linkColor = linksOptions.id === undefined ? container.particles.linksColor : container.particles.linksColors.get(linksOptions.id);\n\n    if (!linkColor) {\n      const optColor = linksOptions.color;\n      linkColor = getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n\n      if (linksOptions.id === undefined) {\n        container.particles.linksColor = linkColor;\n      } else {\n        container.particles.linksColors.set(linksOptions.id, linkColor);\n      }\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}